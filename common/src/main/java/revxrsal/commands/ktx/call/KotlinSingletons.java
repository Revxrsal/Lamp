/*
 * This file is part of Lamp, licensed under the MIT License.
 *
 *  Copyright (c) Revxrsal <reflxction.github@gmail.com>
 *
 *  Permission is hereby granted, free of charge, to any person obtaining a copy
 *  of this software and associated documentation files (the "Software"), to deal
 *  in the Software without restriction, including without limitation the seconds
 *  to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 *  copies of the Software, and to permit persons to whom the Software is
 *  furnished to do so, subject to the following conditions:
 *
 *  The above copyright notice and this permission notice shall be included in all
 *  copies or substantial portions of the Software.
 *
 *  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 *  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *  FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 *  AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 *  LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *  OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 *  SOFTWARE.
 */
package revxrsal.commands.ktx.call;

import lombok.SneakyThrows;
import org.jetbrains.annotations.NotNull;
import org.jetbrains.annotations.Nullable;
import revxrsal.commands.core.reflect.MethodCaller;
import revxrsal.commands.core.reflect.MethodCallerFactory;
import revxrsal.commands.util.Collections;
import revxrsal.commands.util.Preconditions;

import java.lang.reflect.AccessibleObject;
import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.util.Arrays;
import java.util.Map;
import java.util.stream.Collectors;

import static java.lang.reflect.Modifier.isPublic;
import static java.lang.reflect.Modifier.isStatic;
import static revxrsal.commands.ktx.call.KotlinConstants.isStaticFinal;

/**
 * A utility for finding the singleton inside a class
 */
public final class KotlinSingletons {

    /**
     * NOTE: The companion field name is the same as the companion class
     * name, so it may not be necessarily this value.
     */
    private static final String COMPANION_NAME = "Companion";

    private KotlinSingletons() {
    }

    /**
     * Generates a {@link MethodCaller} for the given method, assuming that
     * it is not the synthetic default function generated by the
     * Kotlin compiler.
     *
     * @param method Method to generate for
     * @return The bound method caller
     */
    public static MethodCaller getCallerForNonDefault(
            @NotNull Method method
    ) {
        Class<?>[] parameterTypes = method.getParameterTypes();
        MethodCaller caller = wrapMethod(method);
        boolean isStatic = isStatic(method.getModifiers());
        if (isStatic)
            return caller;

        // an object or a companion object, bind it twice
        if (parameterTypes.length > 0 && parameterTypes[0] == method.getDeclaringClass())
            return (instance, arguments) -> {
                Object[] boundArgs = Collections.insertAtBeginning(arguments, instance);
                return caller.call(instance, boundArgs);
            };

        return caller;
    }

    /**
     * Attempts to find the companion singleton in the given class.
     * This will also search enclosed classes.
     *
     * @param type Type to search for. This should <em>not</em> be
     *             the companion class.
     * @return The companion object
     */
    public static @Nullable Object findCompanion(Class<?> type) {
        Map<String, Field> fields = Arrays
                .stream(type.getDeclaredFields())
                .filter(field -> isPublic(field.getModifiers()) && isStaticFinal(field.getModifiers()))
                .collect(Collectors.toMap(Field::getName, f -> f));

        // try the Companion field
        try {
            Class<?> companion = Class.forName(type.getName() + "$" + COMPANION_NAME);
            Field companionField = fields.get(companion.getSimpleName());
            if (companionField != null)
                return fetch(companionField);
        } catch (ClassNotFoundException ignored) {
        }

        // Companion probably has another name. Look for a class
        // that has a static final field in its parent and has a name
        // that matches it
        for (Class<?> declaredClass : type.getDeclaredClasses()) {
            String name = declaredClass.getSimpleName();
            Field companionField = fields.get(name);
            if (companionField != null) {
                Object singleton = fetch(companionField);
                if (singleton != null)
                    return singleton;
            }
        }
        return null;
    }

    // Auxiliary reflection methods

    private static void makeAccessible(@NotNull AccessibleObject accessibleObject) {
        if (!accessibleObject.isAccessible())
            accessibleObject.setAccessible(true);
    }

    private static Object fetch(@NotNull Field field) {
        try {
            makeAccessible(field);
            return field.get(null);
        } catch (IllegalAccessException e) {
            throw new IllegalStateException("Failed to access the field", e);
        }
    }

    /**
     * A quick function to wrap the given method
     *
     * @param method Method to wrap into a {@link MethodCaller}
     * @return The method caller
     */
    @SneakyThrows
    static MethodCaller wrapMethod(@NotNull Method method) {
        Preconditions.notNull(method, "method");
        return MethodCallerFactory.methodHandles().createFor(method);
    }

}
